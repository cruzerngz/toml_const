//! Codegen implementations for various toml types
//!

use std::{
    collections::HashMap,
    fs::{File, OpenOptions},
    io::Write,
};

use toml::Value;

/// Generate literal rust code that represents the object.
/// Returns the type literal and code literal.
pub trait GenerateCode {
    fn generate_code(&self, inner: bool) -> (String, String);
}

/// Creates code for headers and footers.
///
/// Creates headers on construction
/// and footers on destruction.
pub struct CodeGenWrapper {
    generated_path: String,
    lazy_static_used: bool,
}

impl Drop for CodeGenWrapper {
    fn drop(&mut self) {
        if self.lazy_static_used {
            let mut gen_file = OpenOptions::new()
                .append(true)
                .open(&self.generated_path)
                .unwrap();

            gen_file.write_all("}\n".as_bytes()).unwrap()
        }
    }
}

impl CodeGenWrapper {
    /// Inserts the "lazy_static!" macro and its opening brace.
    ///
    /// The closing brace is inserted when the object is dropped.
    pub fn lazy_static(&mut self, gen_file: &mut File) {
        self.lazy_static_used = true;

        gen_file
            .write_all("lazy_static::lazy_static! {\n".as_bytes())
            .unwrap();
        gen_file.flush().unwrap();
    }

    pub fn new(generated_file: String) -> Self {
        let mut gen_file = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&generated_file)
            .unwrap();

        gen_file
            .write_all(
                "// The contents of this file are automatically generated by build.rs.\n\n"
                    .as_bytes(),
            )
            .unwrap();
        gen_file
            .write_all("#[allow(unused)]\nuse std::collections::HashMap;\n".as_bytes())
            .unwrap();
        gen_file
            .write_all("#[allow(unused)]\nuse std::str::FromStr;\n".as_bytes())
            .unwrap();
        gen_file
            .write_all(
                "#[allow(unused)]\nuse toml::value::{Datetime, Date, Time, Offset};\n\n".as_bytes(),
            )
            .unwrap();

        Self {
            generated_path: generated_file,
            lazy_static_used: false,
        }
    }
}

impl GenerateCode for toml::Value {
    fn generate_code(&self, _inner: bool) -> (String, String) {
        match self {
            Value::String(s) => ("&'static str".to_string(), format!("\"{}\"", s)),
            Value::Integer(i) => ("i64".to_string(), format!("({}_i64)", i)),
            Value::Float(f) => ("f64".to_string(), format!("({}_f64)", f)),
            Value::Boolean(b) => ("bool".to_string(), b.to_string()),
            Value::Datetime(dt) => {
                let date = match dt.date {
                    Some(d) => format!(
                        "Some(Date {{ year: {}, month: {}, day: {} }} )",
                        d.year, d.month, d.day
                    ),
                    None => "None".to_owned(),
                };
                let time = match dt.time {
                    Some(t) => format!(
                        "Some(Time {{ hour: {}, minute: {}, second: {}, nanosecond: {} }} )",
                        t.hour, t.minute, t.second, t.nanosecond
                    ),
                    None => "None".to_owned(),
                };
                let off = match dt.offset {
                    Some(o) => match o {
                        toml::value::Offset::Z => "Some(Offset::Z)".to_owned(),
                        toml::value::Offset::Custom { minutes } => {
                            format!("Some(Offset::Custom {{ minutes: {} }})", minutes)
                        }
                    },
                    None => "None".to_owned(),
                };
                let res = (
                    "Datetime".to_string(),
                    format!(
                        "Datetime {{ date: {}, time: {}, offset: {} }}",
                        date, time, off
                    ),
                );
                res
            }
            Value::Array(a) => a.generate_code(true),
            Value::Table(t) => t.generate_code(true),
        }
    }
}

impl GenerateCode for toml::value::Array {
    /// Type inferred from the first element of the array.
    ///
    /// All elements should be of the same type.
    fn generate_code(&self, _inner: bool) -> (String, String) {
        let code_vec = self
            .iter()
            .map(|elem| elem.generate_code(true))
            .collect::<Vec<(String, String)>>();

        let arr_type = format!(
            "[{}; {}]",
            code_vec
                .get(0)
                .and_then(|tup| Some(tup.0.to_string()))
                .unwrap_or("()".to_string()),
            code_vec.len()
        );

        let mut arr_code = code_vec
            .iter()
            .map(|elem| elem.1.to_owned())
            .collect::<Vec<String>>()
            .join(",\n");

        arr_code = format!("[\n{}\n]", arr_code);

        (arr_type, arr_code)
        // todo!()
    }
}

impl GenerateCode for toml::value::Table {
    /// Creates a hashmap of type <String, String>, regardless of type.
    fn generate_code(&self, _inner: bool) -> (String, String) {
        // header
        let mut gen_literal = "HashMap::from([\n".to_string();

        for (key, val) in self.iter() {
            gen_literal += &format!("(\"{}\", {}.to_string()),", key, val);
        }

        // footer
        gen_literal += "])\n";

        // placeholder
        (String::from("HashMap<&'static str, String>"), gen_literal)
    }
}

/// Turns all last-level tables (tables that do not contain more tables)
/// to a const hashmap.
pub fn generate_last_level_hashmap(table: &toml::Table, prefix: Option<&str>) -> String {
    // check if current table fits criteria
    let last_level = table.iter().all(|(_, val)| match val {
        Value::Table(_) | Value::Array(_) => false,
        _ => true,
    });

    let generated = if last_level {
        // code generated is accumulated into this string
        let mut hash_gen = String::new();
        hash_gen += &format!(
                "/// type: HashMap<&'static str, String>\npub static ref {}: HashMap<&'static str, String> = HashMap::from([\n",
                prefix.unwrap_or("ROOT") // in the event that the entire toml file is a last-level table
            );

        for (key, val) in table.iter() {
            let (_, gen_literal) = val.generate_code(true);
            hash_gen += &format!(
                "(\"{}\", {}.to_string()),\n",
                key.to_uppercase(),
                gen_literal
            );
        }

        hash_gen += "]);\n";
        // enclose hashmap into lazy-static wrapper
        // hash_gen = format!("lazy_static::lazy_static!\n{}\n\n", hash_gen);
        hash_gen
    } else {
        let generated_maps = table
            .iter()
            .map(|(key, val)| {
                let prefix = if let Some(_pre) = prefix {
                    format!("{}_{}", _pre.to_uppercase(), key.to_uppercase())
                } else {
                    key.to_uppercase()
                };

                // taking tables only
                if let toml::Value::Table(t) = val {
                    generate_last_level_hashmap(t, Some(&prefix))
                } else {
                    // ignore the rest
                    String::new()
                }
            })
            .collect::<Vec<String>>()
            .join("\n");

        generated_maps
    };

    generated
}

/// Generate all absolute consts.
pub fn generate_absolute_variables(variables: HashMap<String, Value>) -> String {
    let mut gen = String::new();

    for (key, val) in variables.iter() {
        let (value_type, value_literal) = val.generate_code(false);

        let generated_line = match val {
            Value::Array(_) | Value::Table(_) => {
                format!(
                    "lazy_static::lazy_static!{{\n/// type: {}\npub static ref {}: {} = {};\n}}\n",
                    value_type, key, value_type, value_literal
                )
            }
            _ => format!(
                "/// type: {}\npub const {}: {} = {};\n",
                value_type, key, value_type, value_literal
            ),
        };

        gen += &generated_line;
    }

    gen
}
